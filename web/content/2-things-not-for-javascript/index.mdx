--- 
title: 2 things I never do with Javascript
image: "../../public/images/background/xomtro.jpg"
isPublished: true
publishedDate: 2024-08-26
description: "Javascript is great, but as it is a scripting language, you should avoid these things, I'm sure you will regret (or not)"
authorDisplayName: "Tien Dang"
authorEmail: "tiendvlp@gmail.com"
authorFullName: "Dang Minh Tien"
keywords:
  - Javascript
  - Typescript
---

I have several side projects with Javascript, and had worked in a company that is mainly use Javascript as their main
programing language with more than 90% repositories is written in Javascript. I understand how powerful Javascript is, it bring me both joyful but also angry at the same time. And in this post, I will list out two things that we should avoid when working with Javascript.


## 1. Implement domain or business logic

Javascript is a scripting language, which means our code will be read, optimized, and run on the go during run time
by another program, like V8 on Chrome, or NodeJS or Deno or Bun, etc...

It both include good and bad things.

#### a. The beauty: Easy to create project and *'smooth'* development flow:
Web: one line
```bash
$ npx create-next-app@latest my-shop-web
```

Backend: two lines
```bash
$ npm i -g @nestjs/cli
$ nest new shopping-api
```

And how about the smooth development flow ?

Here is the document for most of the Javscript projects
```bash
# To install dependencies
npm install
# To start a development environment
npm run dev
# Build for production
npm install --production && npm run build
```
And when there are new code changes, we got a super fast hot-reload
feature from existing framework or by using nodemon.

All of these features, which help us init our business ideas within seconds (if your typing speed
and internet speed are fast enough).

#### b. The ugly: Try to get back some features that from 'none-scripting' languages:

Developing a new website or mobile application benefits greatly from the ability to review the UI while writing code, saving us days of work. However, when it comes to backend services, especially those handling business logic (often referred to as domain services), certain features are essential, and they are typically found in strongly-typed, static languages rather than scripting languages.

- **Static typing**: This ensures that the client sends data in the correct format before processing the business logic. And every team member will respect the data type, clear data type bring more productivity and confident to us. Italso guarantees that the final data written to the database is in the proper format, avoiding issues like accidentally storing unnecessary fields. Imagine you are using JsonB in Postgres and by mistake you store the base64-encoded screenshot into the database. Such mistakes can be extremely difficult for test engineers or QA to know.
  
- **Object-oriented support**: Scalability, readability, and maintainability are crucial for domain services, as multiple team members will work and depend on them. And all of these aspect can be archive during the software design phase. Apply SOLID principle, dependency injections, etc,... are keys here. And while you might think these principles donâ€™t depend on any specific language to be implemented, you are right, but OOP languages are still the best fit in this case, offering features like access modifiers (private/public/protected fields and methods), generics, abstract classes. More over we can sure that no one can unintentionally break the system design, it gives us productivity and confident.

- **Error handling**: It's vital to ensure that all exceptions are handled correctly before being forwarded to the client. Every library and dependency should clearly list all potential exceptions, allowing the domain service to determine how to handle them appropriately.

And here some workaround solution if we still want to use Javascript as an all in one solution:
- Switch to Typescript: It will help you reduce 80% effort of data type management, but never reach 100%, because some third party we are using might not well type defined or even not written in Typescript, and because in Typescript we still have `any` type, if any function does accept a parameter as `any`, it is really awful since we have to read part the implementation to know what is it's signature. 
- Linter: You will need to spend some extra effort in finding a suitable eslint rules, but it is important,
linter not just about syntax convention, but it could help your team avoid some common mistakes like `Variable 'a' defined but never be used`.
- Lodash: Always use lodash if you want a good sleep then you have to use it, you never know what could happen with your code on tomorrow or the next release as it is working today it doesn't mean it continue to work because alway someone could be make your code become `Can not read properties of undefined, reading 'property name'`.

#### Summary
Many people said programing language is just a tool, yes, I agree, but how could we change to another language after we have already built a significant portion of our application? Our team are lucky enough to have a chance to choose various tech stack in the early state, we use Rust for all backend services, and alway NextJS for web because that is where Javascript belong to.

I respect Javascript by not using it in any backend services.

## 2. Heavy CPU task
Javascript is singled threaded but very good at asynchornous task because of it's famous [event looping](https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick).

What does that mean to not multi thread but is asynchornous programing ? Let imagine a very simple example that I will give you:

We have a company, you are the business owner, you hire 1 manager and 1 developer team are working for you.

- The daily task of manager is join grooming, start new sprint then close the sprint when it end.
- The daily task of every developer is: Code and code, sometime join the meeting but right after that developer need to go back to the coding task.

In that example, if you have 4 teams, does it require you to hire 3 more managers? It is not, one manager can handle multiple teams at once, Because he not actually done the job but wait until the sprint is end or wait for another meeting, so that, in the mean time he could manage other team rather than just wait and do nothing.

But the coding task is different, if one developer handle two tasks, it will take x2 time, and 3 tasks will take x3 time, etc... It is like a heavy CPU task, without more thread/cpu-core, we are not able to speed up the progress.

Now let's take a look at the code below:

```js
async function asyncCode() {
  const MAX_LOOP = 1000
  let sum = 0
  const subTask1 = async () => {
    for (let i = 0; i < MAX_LOOP * 3; i++) {
      sum += 1
    }

    console.log('task 1 complete')
  }

  const subTask2 = async () => {
    for (let i = 0; i < MAX_LOOP * 2; i++) {
      sum += 1
    }

    console.log('task 2 complete')
  }

  const subTask3 = async () => {
    for (let i = 0; i < MAX_LOOP; i++) {
      sum += 1
    }

    console.log('task 3 complete')
  }

  subTask1()
  subTask2()
  subTask3()
}

asyncCode()
```

The code above define three async task, the first task will loop 3000 times, the second will loop 2000 times, the
third one is loop 1000 times.

If the code is able to run in parallels, the *subTask3* have to be the one who finished first, because its only need to loop 1000 times instead of 3000 like the *subTask1*, but the result will always be:
```sh
$ task 1 complete
$ task 2 complete
$ task 3 complete
```

Something wrong happen here ðŸ§, what's is going on ?

As I said before, Javascript is only single threaded, so that eventhough we are not calling *await subTask1*, but instead it take all the CPU, not release any single milisecond for any other task to have a chance to run, so *subTask2* and *subTask3* have to wait until the *subTask1* is finished it's job.

But wait, what if we add a small delay in each loop, does it help?

Ok ok, I will try to add *1ms delay* on each loop

```js
async function asyncCode() {
  ...
  subTask1
    for ... {
      await sleep(1)
      sum += 1
    }
  }

  subTask2
    for ... {
      await sleep(1)
      sum += 1
    }

  subTask3
    for ... {
      await sleep(1)
      sum += 1
    }

  subTask1()
  subTask2()
  subTask3()
}

...

async function sleep(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms)
  })
}
```

And here is the result:
```sh
$ task 3 complete
$ task 2 complete
$ task 1 complete
```

Exactly what we are expected. But why? It is because the subTask1 are not taking the CPU all time like before, but it will release the CPU 1ms on each loop, giving the main thread a chance to run other tasks.

#### Come to the performance in web development:
When working with React, or any web framework, we should avoid doing long CPU task on the main thread, because it
will making the UI to be freezed. There are some case that my colleges try to parse the
xml file in frontend and while the parsing is in progress, they show the loading circle. It make sense, but the loading animation looks like this... 

![loading](https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExdXNoa20yY2wxOW4ya2g5Z3o1NmNneDk4Zjd2cm9hZmRkbDVsazY3YSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/3o7bu8xhy4eELbgMVy/giphy.gif)

How to solve that problem? The problem is not comming from the long CPU task or the web it self, but because we are not doing it correctly.

We just need to move long CPU task to the [Web worker](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) which help us separate the long CPU task to another 'sub-program', and then, it will never impact the 'main-program' when it is rendering our beautiful UI.

---

## Conclusion

After a long time in software development, I know that the one for all solution doesn't exist, we should
respect the language by understand it's strength and weekness and when we understand, it bring a lot of joyful and productivity to our life.

---

Thank you for your reading, if you enjoy our posts, don't forget to give us a like and a comment below.
